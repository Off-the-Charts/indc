// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package indc

import (
	"github.com/shopspring/decimal"
	"sync"
)

var (
	lockIndicatorMockCalc             sync.RWMutex
	lockIndicatorMockCount            sync.RWMutex
	lockIndicatorMockOffset           sync.RWMutex
	lockIndicatorMockequal            sync.RWMutex
	lockIndicatorMocknamedMarshalJSON sync.RWMutex
)

// Ensure, that IndicatorMock does implement Indicator.
// If this is not the case, regenerate this file with moq.
var _ Indicator = &IndicatorMock{}

// IndicatorMock is a mock implementation of Indicator.
//
//     func TestSomethingThatUsesIndicator(t *testing.T) {
//
//         // make and configure a mocked Indicator
//         mockedIndicator := &IndicatorMock{
//             CalcFunc: func(dd []decimal.Decimal) (decimal.Decimal, error) {
// 	               panic("mock out the Calc method")
//             },
//             CountFunc: func() int {
// 	               panic("mock out the Count method")
//             },
//             OffsetFunc: func() int {
// 	               panic("mock out the Offset method")
//             },
//             equalFunc: func(i Indicator) bool {
// 	               panic("mock out the equal method")
//             },
//             namedMarshalJSONFunc: func() ([]byte, error) {
// 	               panic("mock out the namedMarshalJSON method")
//             },
//         }
//
//         // use mockedIndicator in code that requires Indicator
//         // and then make assertions.
//
//     }
type IndicatorMock struct {
	// CalcFunc mocks the Calc method.
	CalcFunc func(dd []decimal.Decimal) (decimal.Decimal, error)

	// CountFunc mocks the Count method.
	CountFunc func() int

	// OffsetFunc mocks the Offset method.
	OffsetFunc func() int

	// equalFunc mocks the equal method.
	equalFunc func(i Indicator) bool

	// namedMarshalJSONFunc mocks the namedMarshalJSON method.
	namedMarshalJSONFunc func() ([]byte, error)

	// calls tracks calls to the methods.
	calls struct {
		// Calc holds details about calls to the Calc method.
		Calc []struct {
			// Dd is the dd argument value.
			Dd []decimal.Decimal
		}
		// Count holds details about calls to the Count method.
		Count []struct {
		}
		// Offset holds details about calls to the Offset method.
		Offset []struct {
		}
		// equal holds details about calls to the equal method.
		equal []struct {
			// I is the i argument value.
			I Indicator
		}
		// namedMarshalJSON holds details about calls to the namedMarshalJSON method.
		namedMarshalJSON []struct {
		}
	}
}

// Calc calls CalcFunc.
func (mock *IndicatorMock) Calc(dd []decimal.Decimal) (decimal.Decimal, error) {
	if mock.CalcFunc == nil {
		panic("IndicatorMock.CalcFunc: method is nil but Indicator.Calc was just called")
	}
	callInfo := struct {
		Dd []decimal.Decimal
	}{
		Dd: dd,
	}
	lockIndicatorMockCalc.Lock()
	mock.calls.Calc = append(mock.calls.Calc, callInfo)
	lockIndicatorMockCalc.Unlock()
	return mock.CalcFunc(dd)
}

// CalcCalls gets all the calls that were made to Calc.
// Check the length with:
//     len(mockedIndicator.CalcCalls())
func (mock *IndicatorMock) CalcCalls() []struct {
	Dd []decimal.Decimal
} {
	var calls []struct {
		Dd []decimal.Decimal
	}
	lockIndicatorMockCalc.RLock()
	calls = mock.calls.Calc
	lockIndicatorMockCalc.RUnlock()
	return calls
}

// Count calls CountFunc.
func (mock *IndicatorMock) Count() int {
	if mock.CountFunc == nil {
		panic("IndicatorMock.CountFunc: method is nil but Indicator.Count was just called")
	}
	callInfo := struct {
	}{}
	lockIndicatorMockCount.Lock()
	mock.calls.Count = append(mock.calls.Count, callInfo)
	lockIndicatorMockCount.Unlock()
	return mock.CountFunc()
}

// CountCalls gets all the calls that were made to Count.
// Check the length with:
//     len(mockedIndicator.CountCalls())
func (mock *IndicatorMock) CountCalls() []struct {
} {
	var calls []struct {
	}
	lockIndicatorMockCount.RLock()
	calls = mock.calls.Count
	lockIndicatorMockCount.RUnlock()
	return calls
}

// Offset calls OffsetFunc.
func (mock *IndicatorMock) Offset() int {
	if mock.OffsetFunc == nil {
		panic("IndicatorMock.OffsetFunc: method is nil but Indicator.Offset was just called")
	}
	callInfo := struct {
	}{}
	lockIndicatorMockOffset.Lock()
	mock.calls.Offset = append(mock.calls.Offset, callInfo)
	lockIndicatorMockOffset.Unlock()
	return mock.OffsetFunc()
}

// OffsetCalls gets all the calls that were made to Offset.
// Check the length with:
//     len(mockedIndicator.OffsetCalls())
func (mock *IndicatorMock) OffsetCalls() []struct {
} {
	var calls []struct {
	}
	lockIndicatorMockOffset.RLock()
	calls = mock.calls.Offset
	lockIndicatorMockOffset.RUnlock()
	return calls
}

// equal calls equalFunc.
func (mock *IndicatorMock) equal(i Indicator) bool {
	if mock.equalFunc == nil {
		panic("IndicatorMock.equalFunc: method is nil but Indicator.equal was just called")
	}
	callInfo := struct {
		I Indicator
	}{
		I: i,
	}
	lockIndicatorMockequal.Lock()
	mock.calls.equal = append(mock.calls.equal, callInfo)
	lockIndicatorMockequal.Unlock()
	return mock.equalFunc(i)
}

// equalCalls gets all the calls that were made to equal.
// Check the length with:
//     len(mockedIndicator.equalCalls())
func (mock *IndicatorMock) equalCalls() []struct {
	I Indicator
} {
	var calls []struct {
		I Indicator
	}
	lockIndicatorMockequal.RLock()
	calls = mock.calls.equal
	lockIndicatorMockequal.RUnlock()
	return calls
}

// namedMarshalJSON calls namedMarshalJSONFunc.
func (mock *IndicatorMock) namedMarshalJSON() ([]byte, error) {
	if mock.namedMarshalJSONFunc == nil {
		panic("IndicatorMock.namedMarshalJSONFunc: method is nil but Indicator.namedMarshalJSON was just called")
	}
	callInfo := struct {
	}{}
	lockIndicatorMocknamedMarshalJSON.Lock()
	mock.calls.namedMarshalJSON = append(mock.calls.namedMarshalJSON, callInfo)
	lockIndicatorMocknamedMarshalJSON.Unlock()
	return mock.namedMarshalJSONFunc()
}

// namedMarshalJSONCalls gets all the calls that were made to namedMarshalJSON.
// Check the length with:
//     len(mockedIndicator.namedMarshalJSONCalls())
func (mock *IndicatorMock) namedMarshalJSONCalls() []struct {
} {
	var calls []struct {
	}
	lockIndicatorMocknamedMarshalJSON.RLock()
	calls = mock.calls.namedMarshalJSON
	lockIndicatorMocknamedMarshalJSON.RUnlock()
	return calls
}
